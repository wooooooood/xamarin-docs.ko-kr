|속성|설명|옵션|
|--- |--- |--- |
|`abi.type`|**ABI 형식** &ndash; 에뮬레이트된 장치의 ABI (응용 프로그램 이진 인터페이스) 형식을 지정 합니다. 합니다 **x86** 옵션은 일반적으로 라고 "x86" 또는 "IA-32." 설정 명령 합니다 **x86_64** 옵션은 64 비트 x86 명령 집합입니다. 합니다 **armeabi-v7a** 옵션은 v7-a ARM 확장 집합과 ARM 명령입니다. 합니다 **arm64-v8a** 옵션은 AArch64를 지 원하는 ARM 명령 집합 용입니다.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**파티션 캐시** &ndash; 에뮬레이트된 장치에서 사용할지 여부를 결정 한 **캐시/** 장치의 파티션. 합니다 **캐시/** 파티션 (이 처음에 비어 있음)을 Android 앱 구성 요소 및 자주 데이터를 저장 하는 있는 위치입니다. 경우로 **없습니다**, 에뮬레이터를 사용 하지 것입니다는 **캐시/** 파티션과 다른 `disk.cache` 설정이 무시 됩니다.|yes, no|
|`disk.cachePartition.path`|**캐시 파티션 경로** &ndash; 개발 컴퓨터의 캐시 파티션 이미지 파일을 지정 합니다. 에뮬레이터에 대 한이 파일을 사용할지는 **캐시/** 파티션 합니다. 에뮬레이터의 데이터 디렉터리의 상대 경로 또는 절대 경로 입력 합니다. 설정 되지 않은 에뮬레이터 만듭니다 라는 빈 임시 파일 **cache.img** 개발 컴퓨터에 있습니다. 파일이 없으면 빈 파일로 만들어집니다. 이 옵션은 무시 됩니다 `disk.cachePartition` 로 설정 된 **없습니다**합니다.||
|`disk.cachePartition.size`|**캐시 파티션 크기** &ndash; 바이트 단위로 캐시 파티션 파일의 크기입니다. 앱에서 기본 캐시 크기인 66메가바이트를 초과하는 매우 큰 파일을 다운로드하지 않으면 이 옵션은 일반적으로 설정할 필요가 없습니다. 이 옵션은 무시 됩니다 `disk.cachePartition` 로 설정 된 **없습니다**합니다. 이 값이 정수 이면 크기를 바이트 단위로 지정 합니다. 또한 크기 (킬로바이트), 메가바이트 및 기가바이트에 추가 하 여 지정할 수 있습니다 **K**를 **M**, 또는 **G** 값입니다. 최소 크기는 **9m** 최대 크기 이며 **1,023g**합니다.||
|`disk.dataPartition.initPath`|**데이터 파티션에 대 한 초기 경로** &ndash; 데이터 파티션의 초기 콘텐츠를 지정 합니다. 에뮬레이터 사용자 데이터에 지정된 된 파일의 내용을 복사 사용자 데이터를 초기화 한 후 (기본적으로 **userdata-qemu.img**) 사용 하는 대신 **userdata.img** 초기 버전으로 합니다.||
|`disk.dataPartition.path`|**데이터 파티션에 대 한 경로** &ndash; 사용자 데이터 파티션 파일을 지정 합니다. 영구 사용자 데이터 파일을 구성하려면 개발 컴퓨터에 파일 이름과 경로를 입력합니다. 에뮬레이터는 파일이 없으면 기본 파일에서 이미지를 만듭니다 **userdata.img**, 지정 된 파일에 저장 `disk.dataPartition.path`, 에뮬레이터가 종료 될 때 사용자 데이터를 유지 합니다. 경로 지정 하지 않으면 기본 파일 이름은 **userdata-qemu.img**합니다. 특수 값 **<temp>** 하면 에뮬레이터에서 만들고 임시 파일을 사용 합니다. 하는 경우 `disk.dataPartition.initPath` 내용을 복사할 수를 설정 합니다 `disk.dataPartition.path` 부팅 시에는 파일입니다. 이 옵션은 비워 둘 수 없습니다.||
|`disk.dataPartition.size`|**데이터 파티션 크기** &ndash; 사용자 데이터 파티션의 크기를 바이트 단위로 지정 합니다. 이 값이 정수 이면 크기를 바이트 단위로 지정 합니다. 또한 크기 (킬로바이트), 메가바이트 및 기가바이트에 추가 하 여 지정할 수 있습니다 **K**를 **M**, 또는 **G** 값입니다. 최소 크기는 **9m** 최대 크기 이며 **1,023g**합니다.||
|`disk.ramdisk.path`|**Ramdisk 경로** &ndash; 부팅 파티션 (ramdisk) 이미지에 대 한 경로입니다. Ramdisk 이미지는 시스템 이미지를 탑재하기 전에 커널에서 로드되는 시스템 이미지의 하위 집합입니다. Ramdisk 이미지에는 일반적으로 부팅 시 이진 파일 및 초기화 스크립트가 포함됩니다. 이 옵션을 지정 하지 않으면 기본값은 **ramdisk.img** 에뮬레이터 시스템 디렉터리에서.||
|`disk.snapStorage.path`|**스냅숏 저장소 경로** &ndash; 모든 스냅숏이 저장 되는 스냅숏 저장소 파일의 경로입니다. 실행 중에 만든 스냅숏은 모두 이 파일에 저장됩니다. 에뮬레이터를 실행하는 동안 이 파일에 저장된 스냅숏만 복원할 수 있습니다. 이 옵션을 지정 하지 않으면 기본값은 에뮬레이터 데이터 디렉터리의 snapshots.img 합니다.||
|`disk.systemPartition.initPath`|**시스템 파티션 init 경로** &ndash; 시스템 이미지 파일의 읽기 전용 복사본에 대 한 경로, 시스템 라이브러리와 해당 API 수준 및 모든 변형 하는 데이터를 포함 하는 파티션을 특히 합니다. 이 경로 지정 하지 않으면 기본값은 에뮬레이터 시스템 디렉터리에서 system.img 합니다.||
|`disk.systemPartition.path`|**시스템 파티션 경로** &ndash; 읽기/쓰기 시스템 파티션 이미지에 대 한 경로입니다. 이 경로 설정 하지 않으면 경우 임시 파일 생성 되며로 지정 된 파일의 내용에서 초기화 `disk.systemPartition.initPath`합니다.||
|`disk.systemPartition.size`|**시스템 파티션 크기** &ndash; 이상적인 크기 (메가바이트) 시스템 파티션 합니다. 실제 시스템 파티션 이미지가 이 설정보다 크면 해당 크기가 무시됩니다. 그렇지 않으면 시스템 파티션 파일이 커질 수 있는 최대 크기를 지정합니다. 이 값이 정수 이면 크기를 바이트 단위로 지정 합니다. 또한 크기 (킬로바이트), 메가바이트 및 기가바이트에 추가 하 여 지정할 수 있습니다 **K**를 **M**, 또는 **G** 값입니다. 최소 크기는 **9m** 최대 크기 이며 **1,023g**합니다.||
|`hw.accelerometer`|**가 속도계** &ndash; 에뮬레이트된 장치에가 속도계 센서가 포함 되는지 여부를 결정 합니다. 가속도계는 장치에서 방향을 결정하는 데 도움이 됩니다(자동 회전에 사용됨). 가속도계는 3개의 센서 축을 따라 장치의 가속도를 보고합니다.|yes, no|
|`hw.audioInput`|**오디오 녹음 지원** &ndash; 에뮬레이트된 장치에서 오디오를 녹음할 수 있는지 여부를 결정 합니다.|yes, no|
|`hw.audioOutput`|**오디오 재생 지원** &ndash; 에뮬레이트된 장치 오디오를 재생할 수 있는지 여부를 결정 합니다.|yes, no|
|`hw.battery`|**배터리 지원** &ndash; 에뮬레이트된 장치가 배터리에서 실행할 수 있는지 여부를 결정 합니다.|yes, no|
|`hw.camera`|**카메라 지원** &ndash; 에뮬레이트된 장치에 카메라가 있는지 여부를 결정 합니다.|yes, no|
|`hw.camera.back`|**후면 카메라** &ndash; 후면 카메라 (렌즈가 향함 사용자 반대쪽)를 구성 합니다. 개발 컴퓨터에서 웹캠을 사용 하 여 에뮬레이트된 장치에서 후면 카메라를 시뮬레이션 하는,이 값 웹캠 설정 해야 합니다*n*, 여기서 _n_ (웹캠 하나만 있는 경우은 웹캠을 선택 선택할 **webcam0**). 로 에뮬레이트 에뮬레이터가 소프트웨어에서 카메라를 시뮬레이션 합니다. 후면 카메라를 사용 하지 않으려면이 값을 none으로 설정 합니다. 후면 카메라를 사용 하는 경우 반드시 사용 하도록 설정할 수도 `hw.camera`합니다.|emulated, none, webcam0|
|`hw.camera.front`|**전면 카메라** &ndash; 전면 카메라 (사용자 쪽으로 렌즈가)를 구성 합니다. 개발 컴퓨터에서 웹캠을 사용 하 여 에뮬레이트된 장치에서 전면 카메라를 시뮬레이션 하는,이 값 웹캠 설정 해야 합니다*n*, 여기서 _n_ (웹캠 하나만 있는 경우은 웹캠을 선택 를 선택 **webcam0**). 집합을 에뮬레이트할 경우 에뮬레이터가 소프트웨어에서 카메라를 시뮬레이션 합니다. 전면 카메라를 사용 하지 않으려면이 값을 none으로 설정 합니다. 전면 카메라를 사용 하는 경우 반드시 사용 하도록 설정할 수도 `hw.camera`합니다.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**최대 가로 카메라 픽셀** &ndash; 에뮬레이트된 장치의 카메라 픽셀 단위로 최대 가로 해상도 구성 합니다.||
|`hw.camera.maxVerticalPixels`|**최대 세로 카메라 픽셀** &ndash; 에뮬레이트된 장치의 카메라 픽셀 단위로 최대 세로 해상도 구성 합니다.||
|`hw.cpu.arch`|**CPU 아키텍처** &ndash; CPU 아키텍처 가상 장치에서 에뮬레이트할 수입니다. Intel HAXM 하드웨어 가속을 사용 하는 경우 선택할 **x86** 32 비트 CPU에 대 한 합니다. 선택 **x86_64** 64 비트 HAXM 가속 장치의 합니다. (SDK Manager에서 해당 Intel x86 시스템 이미지를 설치 해야 합니다: 예를 들어 Intel x86 Atom 또는 Intel x86 Atom_64.) 을 시뮬레이션 하기 위해 ARM CPU를 선택 **arm** 에 대 한 32 비트 또는 선택 **arm64** 64 비트 ARM CPU에 대 한 합니다. ARM 기반 가상 장치는 ARM에서 하드웨어 가속을 사용할 수 없으므로 x86 기반 가상 장치보다 훨씬 느리게 실행됩니다.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**CPU 모델** &ndash; 이 값은 설정 되지 않은 상태로 일반적으로 (에서 파생 되는 값으로 설정 됩니다 `hw.cpu.arch` 명시적으로 설정 되지 않은 경우). 그러나 실험적 용도로 에뮬레이터 특정 문자열로 설정할 수 있습니다.||
|`hw.dPad`|**DPad 키** &ndash; 에뮬레이트된 장치에서 방향 패드 (DPad) 키를 지원 하는지 여부를 결정 합니다. DPad에는 일반적으로 방향 제어를 나타내는 4개의 키가 있습니다.|yes, no|
|`hw.gps`|**GPS 지원** &ndash; 에뮬레이트된 장치에 GPS (글로벌 위치 시스템) 수신기가 있는지 여부를 결정 합니다.|yes, no|
|`hw.gpu.enabled`|**GPU 에뮬레이션** &ndash; 에뮬레이트된 장치에서 GPU 에뮬레이션을 지원 하는지 여부를 결정 합니다. 사용하도록 설정되면 GPU 에뮬레이션에서 2D 및 3D 그래픽 모두를 화면에 렌더링하기 위해 OpenGL ES(Open GL for Embedded Systems)를 사용하며, 관련 GPU 에뮬레이션 모드 설정은 GPU 에뮬레이션을 구현하는 방법을 결정합니다.|yes, no|
|`hw.gpu.mode`|**GPU 에뮬레이션 모드** &ndash; 에뮬레이터에서 GPU 에뮬레이션을 구현 하는 방법을 결정 합니다. 자동을 선택 하면 에뮬레이터는 개발 컴퓨터 설정에 따라 하드웨어 및 소프트웨어 가속을 선택 합니다. 호스트를 선택 하면 에뮬레이터는 더 빠른 렌더링을 위한 GPU 에뮬레이션을 수행 하려면 개발 컴퓨터의 그래픽 프로세서를 사용 합니다. GPU 에뮬레이터와 호환 되지 않습니다. Windows에서를 호스트 하는 대신 각도 시도할 수 있습니다. 각도 모드는 호스트에 비슷한 성능을 제공 하기 위해 DirectX를 사용 합니다. Mesa을 선택 하면 에뮬레이터 Mesa 3D 소프트웨어 라이브러리를 사용 하 여 그래픽을 렌더링 하는 합니다. 개발 컴퓨터의 그래픽 프로세서를 통해 렌더링 하는 데 문제가 있으면 mesa를 선택 합니다. 컴퓨터의 GPU를 사용 하 여 보다 약간 낮은 성능으로 소프트웨어의 그래픽을 렌더링 하는 swiftshader 모드를 사용할 수 있습니다. Off 옵션 (그래픽 하드웨어 에뮬레이션 사용 안 함) 이며 일부에 대 한 부적절 한 렌더링이 발생할 수 있는 옵션을 사용 되지 않는 항목 권장 되지 않습니다.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**GSM 모뎀 지원** &ndash; 에뮬레이트된 장치에 GSM (Global System for Mobile Communications) 전화 통신 무선 시스템을 지 원하는 모뎀이 포함 되는지 여부를 결정 합니다.|yes, no|
|`hw.initialOrientation`|**초기 화면 방향** &ndash; 화면의 초기 방향 (가로 또는 세로 모드) 에뮬레이트된 장치에서 구성 합니다. 세로 모드에서는 화면의 높이가 너비보다 큽니다. 가로 모드에서는 화면의 너비가 높이보다 큽니다. 장치 프로필에서 세로 및 가로 모드 모두를 지원하는 경우 에뮬레이트된 장치를 실행할 때 방향을 변경할 수 있습니다.|portrait, landscape|
|`hw.keyboard`|**키보드 지원** &ndash; 에뮬레이트된 장치에서 QWERTY 키보드를 지원 하는지 여부를 결정 합니다.|yes, no|
|`hw.keyboard.charmap`|**키보드 문자표 이름** &ndash; 이 장치에 대 한 하드웨어 문자표의 이름입니다. 참고:이 항상 기본 구독 이어야 합니다 **qwerty2** 체제 이미지를 적절 하 게 수정 하지 않는 한 합니다. 이 이름은 부팅 시 커널에 보내집니다. 잘못된 이름을 사용하면 사용할 수 없는 가상 장치가 됩니다.||
|`hw.keyboard.lid`|**키보드 덮개 지원** &ndash; 키보드 지원이 활성화 된 경우이 설정에 따라 결정 아니면 열거나 표시할 여부 QWERTY 키보드 닫힌/를 숨길 수 있습니다. Hw.keyboard false로 설정 된 경우이 설정은 무시 됩니다. 참고: 기본값은 에뮬레이트된 장치에는 API 수준 12 이상을 대상으로 하는 경우 false입니다.|yes, no|
|`hw.lcd.backlight`|**LCD 후광** &ndash; 에뮬레이트된 장치에서는 LCD 후광을 시뮬레이션할지 여부를 결정 합니다.|yes, no|
|`hw.lcd.density`|**LCD 밀도** &ndash; , 밀도 독립적 픽셀 또는 dp 에뮬레이트된 LCD 디스플레이의 밀도 (dp는 가상 픽셀 단위)입니다. 설정이 160dp이면 각 dp가 하나의 물리적 픽셀에 해당합니다. 런타임에 Android에서 이 값을 사용하여 올바른 디스플레이 렌더링에 적절한 리소스/자산을 선택하고 크기를 조정합니다.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**LCD 색 농도** &ndash; LCD 디스플레이 구동 하는 것에 대 한 비트맵을 보유 하는 에뮬레이트된 프레임 버퍼의 색 비트 농도입니다. 이 값은 16비트(65,536개 색 가능) 또는 32비트(16,777,216개 색 + 투명도)일 수 있습니다. 32비트로 설정하면 에뮬레이터가 약간 느리게 실행되지만 색 정확도가 향상됩니다.|16, 32|
|`hw.lcd.height`|**LCD 픽셀 높이** &ndash; 에뮬레이트된 LCD 디스플레이의 수직 크기를 구성 하는 픽셀 수입니다.||
|`hw.lcd.width`|**LCD 픽셀 너비** &ndash; 에뮬레이트된 LCD 디스플레이의 가로 크기를 구성 하는 픽셀 수입니다.||
|`hw.mainKeys`|**하드웨어 뒤로/홈 키** &ndash; 에뮬레이트된 장치 하드웨어 뒤로 지원 하는지 여부 및 홈 탐색 단추를 결정 합니다. 이 값을 설정할 수 있습니다 **예** 소프트웨어 에서만에서 단추를 구현 하는 경우. 하는 경우 `hw.mainKeys` 로 설정 된 **예**, 에뮬레이터 화면에서 탐색 단추 표시 되지 것입니다 하지만를 이러한 단추를 "누를" 에뮬레이터 측면 패널을 사용할 수 있습니다.|yes, no|
|`hw.ramSize`|**장치 RAM 크기** &ndash; 메가바이트에서 에뮬레이트된 장치의 실제 RAM 양입니다. 기본값은 화면 크기 또는 스킨 버전에서 계산됩니다. 크기를 늘리면 에뮬레이터의 작동 속도가 빨라지지만 개발 컴퓨터에서 더 많은 리소스가 필요합니다.||
|`hw.screen`|**터치 스크린 형식** &ndash; 에뮬레이트된 장치의 화면 형식을 정의 합니다. 다중 터치 스크린 터치 인터페이스에서 두 개 이상의 손가락을 추적할 수 있습니다. 터치 스크린에는 한 손가락 터치 이벤트만 감지할 수 있습니다. 아니요-터치 스크린에서 터치 이벤트를 검색 하지 않습니다.|touch, multi-touch, no-touch|
|`hw.sdCard`|**Sd 카드 지원** &ndash; 에뮬레이트된 장치에서 가상 SD (Secure Digital) 카드의 삽입 및 제거를 지원 하는지 여부를 결정 합니다. 에뮬레이터 (hw.sdCard.path 참조) 실제 SD 카드 장치의 파티션을 시뮬레이션 개발 컴퓨터에 저장 된 탑재 가능한 디스크 이미지를 사용 합니다.|yes, no|
|`sdcard.size`|**Sd 카드 크기** &ndash; 지정 된 위치에서 가상 SD 카드 파일의 크기를 지정 `hw.sdCard.path`합니다. (메가바이트) 장치에서 사용할 수 있습니다. 이 값이 정수 이면 크기를 바이트 단위로 지정 합니다. 또한 크기 (킬로바이트), 메가바이트 및 기가바이트에 추가 하 여 지정할 수 있습니다 **K**를 **M**, 또는 **G** 값입니다. 최소 크기는 **9m** 최대 크기 이며 **1,023g**합니다.||
|`hw.sdCard.path`|**Sd 카드 이미지 경로** &ndash; 개발 컴퓨터에 SD 카드 파티션 이미지 파일 경로 파일 이름을 지정 합니다. 예를 들어,이 경로를 설정할 수 없습니다 **C:\sd\sdcard.img** Windows에서.||
|`hw.sensors.magnetic_field`|**자기장 센서** &ndash; 에뮬레이트된 장치에서 자기장 센서를 지원 하는지 여부를 결정 합니다. 자기장 센서(자기계라고도 함)는 3개의 센서 축을 따라 측정된 주위 지자기장을 보고합니다. 컴퍼스 읽기에 액세스해야 하는 앱의 경우 이 설정을 사용하도록 설정합니다. 예를 들어 내비게이션 앱은 이 센서를 사용하여 사용자가 지향하는 방향을 감지할 수 있습니다.|yes, no|
|`hw.sensors.orientation`|**방향 센서** &ndash; 에뮬레이트된 장치 제공 센서 값 방향 하는지 여부를 결정 합니다. 방향 센서는 3개의 모든 물리적 축(x, y, z)을 중심으로 장치가 회전하는 각도를 측정합니다. Android 2.2(API 수준 8)부터는 방향 센서가 지원되지 않습니다.|yes, no|
|`hw.sensors.proximity`|**근접 센서** &ndash; 에뮬레이트된 장치에서 근접 센서를 지원 하는지 여부를 결정 합니다. 이 센서는 개체의 근접 거리를 장치의 보기 화면을 기준으로 측정합니다. 일반적으로 송수화기를 사람의 귀에 대고 있는지 여부를 확인하는 데 사용됩니다.|yes, no|
|`hw.sensors.temperature`|**온도 센서** &ndash; 에뮬레이트된 장치에서 온도 센서를 지원 하는지 여부를 결정 합니다. 이 센서는 온도를 섭씨에서 장치를 측정 (&deg;C).|yes, no|
|`hw.touchScreen`|**터치 스크린 지원** &ndash; 에뮬레이트된 장치에서 터치 스크린을 지원 하는지 여부를 결정 합니다. 터치 스크린은 화면에서 개체를 직접 조작하는 데 사용됩니다.|yes, no|
|`hw.trackBall`|**트랙볼 지원** &ndash; 에뮬레이트된 장치에서 트랙볼 지원 하는지 여부를 결정 합니다.|yes, no|
|`hw.useext4`|**EXT4 파일 시스템 지원** &ndash; 에뮬레이트된 장치 파티션에 대해 Linux EXT4 파일 시스템을 사용 하는지 여부를 결정 합니다. 이제 파일 시스템 형식이 자동으로 감지되므로 이 옵션은 더 이상 사용되지 않으며 무시됩니다.|아니요|
|`kernel.newDeviceNaming`|**커널 새 장치 이름 지정** &ndash; 커널 새 장치 이름 지정 체계가 필요한 지 여부를 지정 하는 데 사용 합니다. 일반적으로 Linux 3.10 커널 이상에서 사용됩니다. 경우로 **autodetect**, 에뮬레이터에서 커널 새 장치 이름 지정 체계가 필요한 지 여부를 자동으로 감지 합니다.|autodetect, yes, no|
|`kernel.parameters`|**커널 매개 변수** &ndash; Linux 커널 부팅 매개 변수의 문자열을 지정 합니다. 이 설정은 기본적으로 비워 둡니다.||
|`kernel.path`|**커널 경로** &ndash; Linux 커널에 대 한 경로 지정 합니다. 이 경로 지정 하지 않으면 에뮬레이터 커널 ranchu 에뮬레이터 시스템 디렉터리에서 찾습니다.||
|`kernel.supportsYaffs2`|**YAFFS2 파티션 지원** &ndash; 커널이 YAFFS2 지원 하는지 여부를 결정 합니다. (아직 다른 Flash File System 2) 파티션 합니다. 일반적으로 Linux 3.10 이전의 커널에만 적용됩니다. 경우 설정 **autodetect** 에뮬레이터에서 커널이 YAFFS2 파일 시스템을 탑재할 수 있는지 여부를 자동으로 감지 합니다.|autodetect, yes, no|
|`skin.name`|**스킨 이름** &ndash; Android 에뮬레이터 스킨에 대 한 이름입니다. 스킨은 에뮬레이터 디스플레이의 시각적 개체 요소 및 컨트롤 요소를 정의하는 파일의 모음입니다. 개발 컴퓨터에 표시되는 AVD 창의 모양을 설명합니다. 스킨은 화면 크기, 단추 및 전체 디자인을 설명하지만 앱 작동에는 영향을 주지 않습니다.||
|`skin.path`|**스킨 경로** &ndash; hardware.ini 레이아웃 파일 및 스킨의 표시 요소에 대 한 이미지 파일을 포함 하는이 디렉터리 skin.name에 지정 된 에뮬레이터 스킨 파일이 포함 된 디렉터리 경로입니다.||
|`skin.dynamic`|**동적 스킨** &ndash; 여부 동적 스킨 인지 합니다. 에뮬레이터에서 지정된 너비와 높이에 따라 지정된 크기의 스킨을 생성하는 경우 에뮬레이터 스킨은 동적 스킨입니다.|아니요|

